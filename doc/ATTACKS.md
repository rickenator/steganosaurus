# ATTACKS.md — Adversarial Red-Team Analysis & Hardening Suggestions

Below is a **practical, adversary-first** breakdown of how an attacker would try to defeat, detect, or disrupt *TurtleFFT / Steganosaurus*, followed by concrete mitigation steps, test recipes, and prioritized engineering fixes you can implement now. I assume the attacker knows the algorithm (Kerckhoffs). The goal here is to turn the design into a defensible research artifact and a robust, low-detectability implementation.

---

## Executive summary (tl;dr)

* **Main detectability risk:** phase distribution changes (±α) in a constrained annulus and repeated keyed traversal across multiple covers.
* **Main confidentiality strength:** ChaCha20-Poly1305 + KDF makes extraction without passphrase infeasible.
* **Main integrity problem:** header is plaintext and not authenticated by AEAD (fix by making header AAD).
* **Best fixes (highest priority):**

  1. Bind header into AEAD as AAD (prevents header tampering / oracle attacks).
  2. Use relative quantization (QIM) instead of absolute ±α nudges.
  3. Make the turtlewalk cover-dependent (eg. pHash||pass) and use per-plane subkeys.
  4. Replace Hamming(7,4) with stronger FEC (LDPC/RS) and use interleaving.
  5. Add per-bin randomized α (small variance) and local masking to reduce phase-histogram artifacts.

---

## Adversarial goal categories

1. **Detect**: decide if an image contains hidden payload.
2. **Localize**: find which spectral bins were changed.
3. **Remove**: corrupt or erase the message without knowing the passphrase (denial).
4. **Recover**: extract payload (requires key or catastrophic implementation bug).
5. **Exploit**: cause malformed header / oracle behavior to leak info.

---

## Concrete attacks and how to carry them out

### A. Phase-histogram (statistical) detector — simplest & powerful

**Idea:** Embedding moves phases toward ±α; over many bins this can create a bimodal peak or reduce phase entropy.

**How to run (attacker):**

1. Compute FFT of image (same padded grid algorithm).
2. Restrict to the embedding annulus (rmin..rmax).
3. For each bin compute θ = atan2(Im,Re).
4. Build histogram `hist(θ)` (e.g., 128 or 256 bins).
5. Compare with a population model (histograms for natural images) using:

   * KL divergence: `D_KL(P || Q)`
   * χ² or Kolmogorov–Smirnov between distributions
   * test stat: relative peak mass within ±Δ of 0 (or ±α)
6. Flag when divergence or peak mass exceeds threshold.

**Why it works:** absolute ±α nudges produce phase concentration; even small α aggregated over many bins creates measurable signal.

**Mitigation:** switch to relative quantization (QIM/STDM) and per-bin randomized offset (tiny σ), or apply small dithering dependent on original phase.

---

### B. Collusion / multi-cover averaging

**Idea:** If same pass is used across many covers, the turtle traverses similar bins; averaging spectra across multiple stego images highlights modified bins (hot spots).

**How to run:**

1. Collect many images suspected to be generated by the same actor.
2. Convert to FFTs and compute `mean_F = mean(FFT(image_i))`.
3. Look for bins with consistent phase/magnitude deviation from population baseline or increased inter-image coherence.

**Mitigation:** derive path_key from pass **and** a perceptual hash of the cover (pHash), or add a per-image nonce that feeds the turtle PRNG. This makes traversal cover-dependent.

---

### C. Cross-channel coherence detector

**Idea:** Applying identical embedding patterns in R/G/B causes unnatural correlation changes between channels in frequency domain.

**How to run:**

* Compute cross-correlation between R/G/B FFT magnitude & phase vectors in annulus and look for deviation from natural correlation statistics.

**Mitigation:** use independent subkeys per channel, or probabilistically vary which plane is written when (so not all three always modified in the same set of bins).

---

### D. Known-cover / chosen-cover attack (worst case)

**Idea:** If the attacker has original cover (or can cause the sender to embed), take FFT difference to directly reveal modifications.

**Reality:** This defeats any stego that edits a known image — unavoidable. Document this limitation clearly.

**Mitigation:** none (design constraint). Emphasize in docs: secure only against detection-only adversaries, not known-cover adversaries.

---

### E. Lossy / removal attacks (denial)

* Low-pass filtering, severe quantization, phase randomization or heavy noise destroys embedded phase info.
* Additive Gaussian noise raises BER until AEAD fails (integrity check), causing rejection.

**Use case:** aggressive image transformations by an adversary will deny retrieval. That's expected: this scheme is lossless-channel only.

---

### F. Header tampering / oracle

**Weakness:** header plaintext (salt, nonce, clen) not authenticated. An adversary can flip `clen`, `nonce`, maybe make the extractor perform out-of-bound reads, or produce many failed attempts to glean timing or error messages.

**Exploit path:**

* Modify `clen` field to cause extractor to read wrong amount and potentially leak bits via timing or error messages.

**Mitigation:** include header bytes as AAD to AEAD seal; only accept header if AEAD verification passes.

---

## Measurable metrics & test procedures (red-team / blue-team)

### 1) Detection strength (attacker)

* **Experiment:** For each payload density `d ∈ {0.05,0.1,0.2,0.3,0.5}` embed many random secrets across a large coverset (e.g., 5k–10k natural images).
* **Compute:** Phase histogram for each cover; compute KL divergence to baseline natural histogram and ROC/AUC of detector.
* **Goal:** plot AUC vs density and α. Target: AUC ≈ 0.5 at operational density.

**Python pseudo (attacker):**

```python
# compute KL divergence between histograms
def kl_div(P, Q, eps=1e-12):
    P = P + eps; Q = Q + eps
    return np.sum(P * np.log(P/Q))
```

### 2) Collusion test

* Embed with same pass across N images.
* Compute `mean_F` and visualize magnitude/phase hotspots.
* Metric: signal-to-noise ratio (SNR) of hotspot vs background.

### 3) BER / Recovery under noise

* Add AWGN, JPEG2000 (lossy), low-pass blur, and measure Bit-Error-Rate, then whether AEAD opens or integrity fails.
* Report: BER vs noise power; probability AEAD verified.

### 4) Visual imperceptibility

* PSNR/SSIM between cover and stego.
* Also run simple perceptual tests (LPIPS) if available.
* Operational guidance: choose parameters that yield PSNR > 50dB and SSIM > 0.995 for near-invisibility.

### 5) Statistical suites

* Use SRM (steganalysis rich model) features + simple classifier (SVM/CART) to measure detection AUC. This is an industry standard for stego evaluation.

---

## Concrete hardening roadmap (ordered, with actionable steps)

### High priority (implement now)

1. **Bind header into AEAD AAD.**

   * When sealing: `seal(key, nonce, AAD = header_bytes, ciphertext)`.
   * When opening: pass same AAD; reject unless AEAD ok.
   * Rationale: prevents header tampering and oracle attacks.

2. **Make turtle path cover-dependent.**

   * `path_key = SHA256(pass || pHash(cover))` or `HKDF(SHA256(pass), info=pHash)`
   * For deterministic extraction you must compute the same pHash on both sides — pick a robust pHash (perceptual hash) that's stable under tiny image metadata differences (use average hash or phash).
   * Rationale: defeats collusion averaging.

3. **Per-plane subkeys from HKDF.**

   * Derive `KS_R`, `KS_G`, `KS_B` via `HKDF(path_key, "R")` etc.
   * Rationale: reduces cross-channel coherence detectors.

4. **Authenticate header + pad clen.**

   * Keep header compact, pass as AAD. Add random padding to ciphertext length to avoid metadata leaks.

5. **Replace absolute ±α embedding with *relative quantization* (QIM or STDM).**

   * Let φ0 be original phase. Choose quantization step Δ and represent bit via nearest quantization cell: `φ' = Q(φ0, bit)` where quantization centers are shifted by Δ/2 for bit=1 vs bit=0 — but do it **relative** to φ0, not absolute ±α.
   * Add random small dither per bin (σ tiny) from KS.
   * Rationale: QIM reduces a fixed offset signature in the global phase histogram.

### Medium priority (research & refine)

6. **Per-bin randomized α (tiny variance).**

   * Instead of constant α, sample α_i ~ N(μ, σ²) with μ small. Use KS to sample.
   * Rationale: blurs histogram peaks.

7. **Stronger FEC + interleaving.**

   * Replace Hamming(7,4) with Reed-Solomon or LDPC for moderate overhead; add interleaving across turtle sequence to distribute burst errors.
   * Rationale: more resilient to noise and targeted bin corruption.

8. **Adaptive masking (content-aware).**

   * Compute local spectral contrast and elevate α only where mask is strong (higher mag relative to median). Use per-bin SNR threshold.
   * Rationale: hide changes in "busy" spectrum.

9. **Payload rate control & conservative defaults.**

   * Document defaults: density ≤ 0.25, α ≤ 0.25 rad (tune experimentally). Provide safe presets (e.g., `--mode stealth`, `--mode throughput`).

10. **Operational mitigations & UX**

    * Random delay or small cover pre-processing steps (slight gamma mapping) to break pattern repeatability across uploads.
    * Offer a unique per-image nonce option (but keep path deterministic if you want extraction by pass only).

### Lower priority (longer research)

11. **Train adversarial detectors** (you want to know what a strong detector finds).

    * Run CNN detectors on raw pixels and on SRM features to estimate realistic AUCs; use this to pick parameter tradeoffs.

12. **Explore LDPC with belief propagation decoders** for high reliability vs capacity tradeoffs.

---

## Recommended code changes (patch-level)

1. **Header AAD (example):**

```cpp
// During encryption:
vector<uint8_t> header_bytes = Hdr.to_bytes();
chacha20_poly1305_seal(km.aead_key.data(), km.nonce.data(),
                      header_bytes.data(), header_bytes.size(),
                      ct.data(), ct.size(), tag.data());

// During decryption:
vector<uint8_t> header_bytes = Hdr.to_bytes();
if(!chacha20_poly1305_open(km.aead_key.data(), km.nonce.data(),
                           header_bytes.data(), header_bytes.size(),
                           ct.data(), ct.size(), tag.data())) {
    // auth failed
}
```

2. **Turtle path derivation**

```cpp
// path_key = SHA256(pass || pHash(cover))
auto ph = phash_of_image(img_bytes);
string seed = pass + string((char*)ph.data(), ph.size());
auto path_key = sha256::hash(seed);
```

3. **Per-plane KS**

```cpp
// derive 3 subkeys
uint8_t sub[32*3];
sha256::hkdf_sha256_expand(prk, (const uint8_t*)"pathkey_expand", 15, sub, 96);
KS ks_r(array<uint8_t,32>(sub+0), true);
KS ks_g(array<uint8_t,32>(sub+32), true);
KS ks_b(array<uint8_t,32>(sub+64), true);
```

4. **Relative QIM (sketch)**

```cpp
// embed: quantize relative to φ0
double phi0 = atan2(v.imag(), v.real());
double step = Δ; // e.g., Δ = small radian
double center = floor(phi0/step)*step + (bit? step/2 : 0);
double phi_new = center + ks.jitter(sigma);
v = polar(mag, phi_new);
```

5. **Stronger ECC**

* Replace ham74 with Reed-Solomon over bytes or an LDPC library. If you prefer single-file C++ you can integrate a small RS implementation or use existing public domain code.

---

## Tests you should run (practical checklist)

* [ ] **KL diverge sweep:** vary α ∈ {0.05..0.4}, density ∈ {0.05..0.5}, compute KL vs natural histograms for 5k images.
* [ ] **Collusion test:** same pass used on 100 images → compute mean FFT and visualize hotspots.
* [ ] **Cross-channel correlation test:** measure correlation change between R/G/B pre/post embed.
* [ ] **BER vs AWGN/JPEG:** measure BER and AEAD accept rate across noise strengths and JPEG Q values.
* [ ] **SRM classifier:** compute SRM features and train a simple classifier between cover/stego; report AUC.
* [ ] **Human perceptual test:** side-by-side observer test on random samples (blind).

---

## Detection & counter-detection recipes (for your lab)

* **Phase histogram KL** (fast): target for automation.
* **2D heatmap of mean phase across many images** (collusion).
* **SRM + ensemble classifier** (strong machine test).
* **Wavelet/scale analysis**—embedding in midband may change wavelet coefficients; test wavelet statistic drift.

---

## Practical operational guidance (what to ship)

* Default to **very conservative** parameters: `density=0.25`, `alpha` small or use QIM default, `pbkdf2_iter` high but allow user control; provide `--stealth` preset that trades capacity for lower detectability.
* Warn users in README about **known limitations** (lossy transforms, known-cover attacks).
* Provide a `--test` mode that runs local detection metrics and prints PSNR/SSIM/KL so the user can evaluate a given cover before embedding.
* Provide a **nonce mode** for per-image unique embedding (useful when user wants unlinkability across images).

---

## Research questions (for a paper / future experiments)

1. How small can Δ (relative quantization step) be while still enabling robust decoding at modest capacity? (tradeoff: detectability vs BER)
2. How much does cover-dependence of the path reduce collusion detection AUC?
3. Which FEC + interleaving scheme provides the best capacity vs reliability under AWGN-like spectral perturbations?
4. What is the minimal payload at which phase histogram detectors reach AUC>0.95 across a 10k image corpus?

---

## Example quick experiments (python pseudocode)

1. **Phase histogram KL sweep**

```python
for density in [0.1, 0.2, 0.3]:
    for alpha in [0.05, 0.1, 0.2]:
        stego_hist = compute_phase_histograms(stego_images_sent)
        natural_hist = compute_phase_histograms(natural_images)
        kl = kl_div(stego_hist, natural_hist)
        print(density, alpha, kl)
```

2. **Collusion mean FFT**

```python
mean_fft = np.mean([fft2(image) for image in stego_images_with_same_pass], axis=0)
# visualize phase/magnitude heatmap
```

---

## Final thoughts (red team voice)

* The *core idea* is elegant — embedding in phase with a keyed path and AEAD gives strong confidentiality and the potential for low detectability.
* The *main weakness* is statistical artifacts (phase histogram and cross-image correlation) and the unauthenticated header.
* With the fixes above you substantially raise the bar: per-cover path keys, relative quantization, randomized tiny dithers, per-plane subkeys, and real FEC will make detection much harder and make the scheme a stronger research contribution.

---

## Next steps

* Produce a PR patch that implements **header as AAD**, **per-plane HKDF subkeys**, and a **QIM embed option** (small diff + tests), or
* [FUTURE] Write up a reproducible experiment that runs the KL/ROC sweeps over a folder of natural images so one can pick safe defaults empirically.
